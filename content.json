{"meta":{"title":"Formyown的博客","subtitle":null,"description":null,"author":"Formyown","url":"http://formyown.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-07-29T08:23:34.916Z","updated":"2020-07-29T08:23:34.916Z","comments":false,"path":"/404.html","permalink":"http://formyown.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-29T08:23:34.920Z","updated":"2020-07-29T08:23:34.920Z","comments":false,"path":"about/index.html","permalink":"http://formyown.github.io/about/index.html","excerpt":"","text":"本科，毕业于 University of Wollongong (Sydney, Australia) 计算机科学专业，软件工程方向 拥有丰富的软件开发经验 熟悉常见编程语言包含 Java, Kotlin, C#, C/C++, JavaScript, TypeScript, Lua, Python, Smali, 汇编等。 熟悉软件开发框架包含 SpringBoot, SpringCloud, NestJs, express, Vue, React, Mpx 等。 熟悉.NET core, nodejs, electron, jvm等环境应用开发。 有一定的嵌入式基础，了解8051, AVR, ARM嵌入式系统开发。 有一定的硬件基础。 目前专注于后端技术，高性能高可用WEB应用开发，微服务架构设计。 现就职于北京捷天科技有限责任公司 全栈开发工程师 2016年10月-2018年12月 专注于开发区块链钱包项目，后端开发工程师&amp;架构设计 2016年5月-2018年9月 专注于开发广告投放平台，后端开发工程师 2016年之前 专注于开发个人项目"},{"title":"书单","date":"2020-07-29T08:23:34.920Z","updated":"2020-07-29T08:23:34.920Z","comments":false,"path":"books/index.html","permalink":"http://formyown.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-07-29T08:23:34.920Z","updated":"2020-07-29T08:23:34.920Z","comments":false,"path":"categories/index.html","permalink":"http://formyown.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-29T08:23:34.920Z","updated":"2020-07-29T08:23:34.920Z","comments":true,"path":"links/index.html","permalink":"http://formyown.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-07-29T08:23:34.920Z","updated":"2020-07-29T08:23:34.920Z","comments":false,"path":"repository/index.html","permalink":"http://formyown.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-29T08:23:34.920Z","updated":"2020-07-29T08:23:34.920Z","comments":false,"path":"tags/index.html","permalink":"http://formyown.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Netty获取并检查Websocket握手请求","slug":"Netty获取并检查Websocket握手请求","date":"2020-07-29T12:00:00.000Z","updated":"2020-07-29T08:23:34.920Z","comments":true,"path":"2020/07/29/Netty获取并检查Websocket握手请求/","link":"","permalink":"http://formyown.github.io/2020/07/29/Netty获取并检查Websocket握手请求/","excerpt":"","text":"在使用Netty开发Websocket服务时，通常需要解析来自客户端请求的URL、Headers等等相关内容，并做相关检查或处理。本文将讨论两种实现方法。 方法一：基于HandshakeComplete自定义事件 特点：使用简单、校验在握手成功之后、失败信息可以通过Websocket发送回客户端。 1.1 从netty源码出发 一般地，我们将netty内置的WebSocketServerProtocolHandler作为Websocket协议的主要处理器。通过研究其代码我们了解到在本处理器被添加到Pipline后handlerAdded方法将会被调用。此方法经过简单的检查后将WebSocketHandshakeHandler添加到了本处理器之前，用于处理握手相关业务。 我们都知道Websocket协议在握手时是通过HTTP(S)协议进行的，那么这个WebSocketHandshakeHandler应该就是处理HTTP相关的数据的吧？ 下方代码经过精简，放心阅读😄 123456789101112131415package io.netty.handler.codec.http.websocketx;public class WebSocketServerProtocolHandler extends WebSocketProtocolHandler &#123; @Override public void handlerAdded(ChannelHandlerContext ctx) &#123; ChannelPipeline cp = ctx.pipeline(); if (cp.get(WebSocketServerProtocolHandshakeHandler.class) == null) &#123; // Add the WebSocketHandshakeHandler before this one. cp.addBefore(ctx.name(), WebSocketServerProtocolHandshakeHandler.class.getName(), new WebSocketServerProtocolHandshakeHandler(serverConfig)); &#125; //... &#125;&#125; 我们来看看WebSocketServerProtocolHandshakeHandler都做了什么操作。 channelRead方法会尝试接收一个FullHttpRequest对象，表示来自客户端的HTTP请求，随后服务器将会进行握手相关操作，此处省略了握手大部分代码，感兴趣的同学可以自行阅读。 可以注意到，在确认握手成功后，channelRead将会调用两次fireUserEventTriggered，此方法将会触发其他（在此处理器之后）的处理器中名为的serEventTriggered方法。其中一个方法传入了WebSocketServerProtocolHandler对象，此对象保存了HTTP请求相关信息。那么解决方案逐渐浮出水面，通过监听自定义事件即可实现检查握手的HTTP请求。 12345678910111213141516171819202122232425262728293031323334package io.netty.handler.codec.http.websocketx;/** * Handles the HTTP handshake (the HTTP Upgrade request) for &#123;@link WebSocketServerProtocolHandler&#125;. */class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception &#123; final FullHttpRequest req = (FullHttpRequest) msg; if (isNotWebSocketPath(req)) &#123; ctx.fireChannelRead(msg); return; &#125; try &#123; //... if (!future.isSuccess()) &#123; &#125; else &#123; localHandshakePromise.trySuccess(); // Kept for compatibility ctx.fireUserEventTriggered( WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HANDSHAKE_COMPLETE); ctx.fireUserEventTriggered( new WebSocketServerProtocolHandler.HandshakeComplete( req.uri(), req.headers(), handshaker.selectedSubprotocol())); &#125; &#125; finally &#123; req.release(); &#125; &#125;&#125; 1.2 解决方案 下面的代码展示了如何监听自定义事件。通过抛出异常可以终止链接，同时可以利用ctx向客户端以Websocket协议返回错误信息。因为此时握手已经完成，所以虽然这种方案简单的过分，但是效率并不高，耗费服务端资源。 12345678910private final class ServerHandler extends SimpleChannelInboundHandler&lt;DeviceDataPacket&gt; &#123; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) &#123; // 在此处获取URL、Headers等信息并做校验，通过throw异常来中断链接。 &#125; super.userEventTriggered(ctx, evt); &#125;&#125; 1.3 ChannelInitializer实现 附上Channel初始化代码作为参考。 12345678910111213private final class ServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) &#123; ch.pipeline() .addLast(\"http-codec\", new HttpServerCodec()) .addLast(\"chunked-write\", new ChunkedWriteHandler()) .addLast(\"http-aggregator\", new HttpObjectAggregator(8192)) .addLast(\"log-handler\", new LoggingHandler(LogLevel.WARN)) .addLast(\"ws-server-handler\", new WebSocketServerProtocolHandler(endpointUri.getPath())) .addLast(\"server-handler\", new ServerHandler()); &#125;&#125; 方法二：基于新增安全检查处理器 特点：使用相对复杂、校验在握手成功之前、失败信息可以通过HTTP返回客户端。 2.1 解决方案 编写一个入站处理器，接收FullHttpMessage消息，在Websocket处理器之前检测拦截请求信息。下面的例子主要做了四件事情： 从HTTP请求中提取关心的数据 安全检查 将结果和其他数据绑定在Channel 触发安全检查完毕自定义事件 1234567891011121314151617181920212223242526272829303132public class SecurityServerHandler extends ChannelInboundHandlerAdapter &#123; private static final ObjectMapper json = new ObjectMapper(); public static final AttributeKey&lt;SecurityCheckComplete&gt; SECURITY_CHECK_COMPLETE_ATTRIBUTE_KEY = AttributeKey.valueOf(\"SECURITY_CHECK_COMPLETE_ATTRIBUTE_KEY\"); @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; if(msg instanceof FullHttpMessage)&#123; //extracts device information headers HttpHeaders headers = ((FullHttpMessage) msg).headers(); String uuid = Objects.requireNonNull(headers.get(\"device-connection-uuid\")); String devDescJson = Objects.requireNonNull(headers.get(\"device-description\")); //deserialize device description DeviceDescription devDesc = json.readValue(devDescJson, DeviceDescriptionWithCertificate.class); //check ...... // SecurityCheckComplete complete = new SecurityCheckComplete(uuid, devDesc); ctx.channel().attr(SECURITY_CHECK_COMPLETE_ATTRIBUTE_KEY).set(complete); ctx.fireUserEventTriggered(complete); &#125; //other protocols super.channelRead(ctx, msg); &#125; @Getter @AllArgsConstructor public static final class SecurityCheckComplete &#123; private String connectionUUID; private DeviceDescription deviceDescription; &#125;&#125; 在业务逻辑处理器中，可以通过组合自定义的安全检查事件和Websocket握手完成事件。例如，在安全检查后进行下一步自定义业务检查，在握手完成后发送自定义内容等等，就看各位同学自由发挥了。 12345678910111213141516171819 private final class ServerHandler extends SimpleChannelInboundHandler&lt;DeviceDataPacket&gt; &#123; public final AttributeKey&lt;DeviceConnection&gt; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if (evt instanceof SecurityCheckComplete)&#123; log.info(\"Security check has passed\"); SecurityCheckComplete complete = (SecurityCheckComplete) evt; listener.beforeConnect(complete.getConnectionUUID(), complete.getDeviceDescription()); &#125; else if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) &#123; log.info(\"Handshake has completed\"); SecurityCheckComplete complete = ctx.channel().attr(SecurityServerHandler.SECURITY_CHECK_COMPLETE_ATTRIBUTE_KEY).get(); DeviceDataServer.this.listener.postConnect(complete.getConnectionUUID(), new DeviceConnection(ctx.channel(), complete.getDeviceDescription())); &#125; super.userEventTriggered(ctx, evt); &#125;&#125; 2.2 ChannelInitializer实现 附上Channel初始化代码作为参考。 123456789101112131415private final class ServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) &#123; ch.pipeline() .addLast(\"http-codec\", new HttpServerCodec()) .addLast(\"chunked-write\", new ChunkedWriteHandler()) .addLast(\"http-aggregator\", new HttpObjectAggregator(8192)) .addLast(\"log-handler\", new LoggingHandler(LogLevel.WARN)) .addLast(\"security-handler\", new SecurityServerHandler()) .addLast(\"ws-server-handler\", new WebSocketServerProtocolHandler(endpointUri.getPath())) .addLast(\"packet-codec\", new DataPacketCodec()) .addLast(\"server-handler\", new ServerHandler()); &#125;&#125; 总结 上述两种方式分别在握手完成后和握手之前拦截检查；实现复杂度和性能略有不同，可以通过具体业务需求选择合适的方法。 Netty增强了责任链模式，使用userEvent传递自定义事件使得各个处理器之间减少耦合，更专注于业务。但是、相比于流动于各个处理器之间的&quot;主线&quot;数据来说，userEvent传递的&quot;支线&quot;数据往往不受关注。通过阅读Netty内置的各种处理器源码，探索其产生的事件，同时在开发过程中加以善用，可以减少冗余代码。另外在开发自定义的业务逻辑时，应该积极利用userEvent传递事件数据，降低各模块之间代码耦合。","categories":[{"name":"Netty","slug":"Netty","permalink":"http://formyown.github.io/categories/Netty/"},{"name":"Websocket","slug":"Netty/Websocket","permalink":"http://formyown.github.io/categories/Netty/Websocket/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://formyown.github.io/tags/Netty/"},{"name":"Websocket","slug":"Websocket","permalink":"http://formyown.github.io/tags/Websocket/"}]},{"title":"Decimaljs在class-transformer中异常的解决方案","slug":"Decimaljs在class-transformer中异常的解决方案","date":"2019-12-17T03:07:09.000Z","updated":"2020-07-29T08:23:34.916Z","comments":true,"path":"2019/12/17/Decimaljs在class-transformer中异常的解决方案/","link":"","permalink":"http://formyown.github.io/2019/12/17/Decimaljs在class-transformer中异常的解决方案/","excerpt":"","text":"背景 在使用class-transformer进行对象转换并且遇到类型为Decimal的数据时工作不正常 异常复现 我们有以下类型，是目标对象： 1234567export class OrderItemTransfer &#123; ///忽略其他无关内容 @Expose() price: Decimal;&#125; 以及，源对象定义： 123456789101112@Entity()export class OrderItem &#123; ///忽略其他无关内容 @Column(&#123; type: \"decimal\", precision: 5, scale: 2, default: 0, transformer: new DecimalTransformer() &#125;) price: Decimal;&#125; 我们的目标是将 OrderItem 类型的对象转换到 OrderItemTransfer 类型。于是有以下代码： 123let transfer = plainToClass(OrderItemTransfer, entity);//发生异常: Error//Error: [DecimalError] Invalid argument: undefined 异常分析 通过追踪调用栈发现如下信息: 找到调用Decimal构造函数的具体代码 可以看到，这里直接调用了Decimal构造函数，然而Decimal的构造函数并不支持参数是null/undefined从而引发了异常。 plainToClass这个方法的设计是针对plain object到class的转换，通过下图可见，他的类型判断相对简单 在判断对象类型是object之后并没有进一步判断构造函数相关信息（针对plain object的设计并不需要判断，因为这种情况并不存在自定义的构造函数）。但是这种特性恰巧妨碍了我们使用类似于Decimal这种没有默认构造函数的类型。 解决方案 其实2017年已经有人提过这个问题，但是这种情况确实是此方法的设计情况之外，而且官方也并没有给出解决方案。仅有某位用户提供的一个临时性的解决方案: 123else if (value[valueKey] instanceof Function) &#123; subValue = value[valueKey](); --&gt; Comment out this line&#125; 这个解决方案真的能解决问题么？答案是：可以，但不优雅。 与其提交pr给class-transformer不如从另外一个角度来解决，那就是从Decimal.js下手。由于问题发生在Decimal类型没有默认的构造函数，那么我们为何不拓展以下这个类型呢？ 12345678class DecimalPatch &#123; constructor(v) &#123; if (!v) v = 0; let d = new Decimal(v) as any; delete d.constructor; Object.assign(this, d); &#125;&#125; 看到这里，你可能要问几个问题： 为什么不用extends呢？答案是class-transformer拿到的类型仍是Decimal的构造函数 为什么要delete d.constructor呢？答案是防止plainToClass再次调用constructor (这个方法很迷，它会调用源对象的所有方法求值赋值给目标对象，看似是为了调用getter作用的函数，但是并没有判断能力，就连构造函数也不放过QAQ。。。) 现在，你可以这样使用它 12345678910111213@Entity()export class OrderItem &#123; ///忽略其他无关内容 @Column(&#123; type: \"decimal\", precision: 5, scale: 2, default: 0, transformer: new DecimalTransformer() //还记得这里么， //解释一下，DecimalTransformer是用于将数据库查询出的数据转换为自定义数据 &#125;) price: Decimal;&#125; 它长这个样子 12345678export class DecimalTransformer implements ValueTransformer &#123; to(data: Decimal): string &#123; return data.toString(); &#125; from(data: string): Decimal &#123; return new Decimal(data); //这里实例化了对象 &#125;&#125; 那么我们可以修改上述代码： 123from(data: string): DecimalPatch &#123; return new DecimalPatch(data);&#125; 这样，entity中的数据实际类型是DecimalPatch，并且工作一切正常","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://formyown.github.io/categories/JavaScript/"},{"name":"TypeScript","slug":"JavaScript/TypeScript","permalink":"http://formyown.github.io/categories/JavaScript/TypeScript/"}],"tags":[{"name":"Decimal.js","slug":"Decimal-js","permalink":"http://formyown.github.io/tags/Decimal-js/"},{"name":"class-transformer","slug":"class-transformer","permalink":"http://formyown.github.io/tags/class-transformer/"}]},{"title":"Ethereum以太坊签名验证算法Java实现","slug":"Ethereum以太坊签名验证算法Java实现","date":"2019-02-16T15:41:00.000Z","updated":"2020-07-29T08:23:34.920Z","comments":true,"path":"2019/02/16/Ethereum以太坊签名验证算法Java实现/","link":"","permalink":"http://formyown.github.io/2019/02/16/Ethereum以太坊签名验证算法Java实现/","excerpt":"","text":"开始之前 在验证之前，我们需要这些基本的信息: 签名，原文，地址（或者公钥） Sig: 0x5f3c4ab309427d25cdc34a41cb432610c6c817e76ce9aec0c9336365063687ff29c92963edd6935f365d5f28c146f227881b626c7db18e87b9baf2089729741b1c Message: 签名这段文字以验证你是这个账户的持有者。 Address: 0x1c52C6F743351fC9b97AE4Fe32194A588398FE69 处理原文 首先我们需要将原为处理为Hash形式 1MessageHash = keccak256(prefix + message) 这个prefix是个什么东西？ 我们来看看签名在生成的时候是如何计算的。在Ethereum官方文档中，关于eth_sig的描述是这样的： 可疑的地方是sign(keccak256(&quot;\\x19Ethereum Signed Message:\\n&quot; + len(message) + message)))，我们可以看到在message之前添加了一段话：&quot;\\x19Ethereum Signed Message:\\n&quot; + len(message)。真正被签名的数据不是单纯的message，而是在message之前添加了这句话（prefix）后整体做了hash运算。所以，我们在计算hash的时候，也需要照做。 123String message = \"签名这段文字以验证你是这个账户的持有者。\";byte[] msgBuffer = message.getBytes(\"UTF-8\");byte[] msgPrefix = (\"\\u0019Ethereum Signed Message:\\n\" + msgBuffer.length).getBytes(\"UTF-8\"); 现在已经将原始消息和prefix都转换成了字节数组的形式，接下来需要把这两部分拼接起来 123byte[] msg = new byte[msgPrefix.length + msgBuffer.length];System.arraycopy(msgPrefix, 0, msg, 0, msgPrefix.length);System.arraycopy(msgBuffer, 0, msg, msgPrefix.length, msgBuffer.length); 毫无难度，利用System.arraycopy方法可以轻松得拷贝数组，得到msg后，就可以计算keccak256(msg)了 1234import org.ethereum.crypto.cryptohash.Keccak256;Keccak256 keccak256 = new Keccak256();byte[] msgHash = keccak256.copy().digest(msg); 这里使用了ethereumj的加密包，当然你也可以使用其他的包或者自己实现keccak256。 结果：msgHash = 767cab717f7e9a3f56765c89f39887b9934a8e78ad4d0a2fb1fd0d009bb7012b (32字节，HEX) 好了，到目前为止msgHash已经拿到了，接下来就要处理签名了 处理签名 再来看一眼签名: 0x5f3c4ab309427d25cdc34a41cb432610c6c817e76ce9aec0c9336365063687ff29c92963edd6935f365d5f28c146f227881b626c7db18e87b9baf2089729741b1c 长度是65个字节。 然而这段签名是由三部分组成的。它们分别是 r, s, v。r和s长度都是32字节，v是一个字节。下面的代码将会吧签名拆分成上述部分。 12345import org.bouncycastle.util.encoders.Hex;byte[] r = Hex.decode(sig.substring(0, 64));byte[] s = Hex.decode(sig.substring(64, 128));byte v = Hex.decode(sig.substring(128, 130))[0]; 结果： r = 5f3c4ab309427d25cdc34a41cb432610c6c817e76ce9aec0c9336365063687ff (32字节，HEX) s = 29c92963edd6935f365d5f28c146f227881b626c7db18e87b9baf2089729741b (32字节，HEX) v = 28 (10进制) 得到这三个数据以后，就可以进入下一个环节辣 什么是椭圆曲线数字签名算法 若果你不想了解或者已经了解椭圆曲线的细节，可以跳过此小节 ECDSA，EC，和Secp256k1 以太坊使用的是Elliptic Curve Digital Signature Algorithm (ECDSA，椭圆曲线数字签名算法)进行签名。可是Elliptic Curve(EC，椭圆曲线)又是个什么东西？ 为了有一个直观感受，这里有一个简单但是通用的方程 y2=x3+ax+by^2 = x^3 + ax + by2=x3+ax+b 其中a都是常数b，不同的取值会形成不同的曲线方程 在这里https://www.desmos.com/calculator/9vv5aklebf，你可以调整a和b的值来观察不同的取值 这些方程和加密有什么联系么？当然！不过首先要了解什么是群以及加法 群(Groups) 和阿贝尔群 群：若 非空 集合 𝔾, 定义在 𝔾 上的一个二元运算：加法，符号+表示，满足： 封闭性：存在a,b∈𝔾a,b\\in𝔾a,b∈G, (a+b)∈𝔾(a+b)\\in𝔾(a+b)∈G 结合律：存在a,b,c∈𝔾a,b,c\\in𝔾a,b,c∈G, (a+b)+c=a+(b+c)(a+b)+c = a+(b+c)(a+b)+c=a+(b+c) 交换律：存在a,b∈𝔾a,b\\in𝔾a,b∈G, a+b=b+aa+b = b+aa+b=b+a 单位元：集合 𝔾 中有一个确切的值即单位元000，使得 a+0=0+a=aa+0=0+a=aa+0=0+a=a 逆元：集合 𝔾 中每个成员都有其相反数，即a+b=0a+b=0a+b=0 则(𝔾,+)(𝔾,+)(G,+)称为一个群，或者加法群也叫阿贝尔群。 椭圆曲线上的加法 假设曲线y2=x3+7y^2 = x^3 + 7y2=x3+7上有两个点，PPP和QQQ P=(x1,y1)P = (x_1, y_1)P=(x1​,y1​) Q=(x2,y2)Q = (x_2, y_2)Q=(x2​,y2​) 过 PPP 和 QQQ 做一条直线，相交于曲线 R′R&#x27;R′ 过 R′R&#x27;R′ 做 XXX 轴垂线并相交于曲线 RRR 那么 P+Q=RP + Q = RP+Q=R 如何计算 P+QP + QP+Q 访问 https://www.desmos.com/calculator/fttnxuzryp 查看更多关于计算的细节 我们已经知道了 PPP 和 QQQ,又 P=(x1,y1)P = (x_1, y_1)P=(x1​,y1​) Q=(x2,y2)Q = (x_2, y_2)Q=(x2​,y2​) 那么过这两点直线的斜率 k=(y2−y1)/(x2−x1)k = (y_2-y_1)/(x_2-x_1)k=(y2​−y1​)/(x2​−x1​) 设 R=(x3,y3)R=(x_3,y_3)R=(x3​,y3​) x3=k2−x1−x2x_3 = k^2 - x_1 - x_2x3​=k2−x1​−x2​ y3=k(x1−x3)−y1y_3 = k(x_1 - x_3) - y_1y3​=k(x1​−x3​)−y1​ 椭圆曲线和阿贝尔群 上述对于椭圆曲线上加法的描述和解析使我们得知PPPQQQRRR都是曲线上的点，且满足阿贝尔群的定义。不难证明椭圆曲线上的加法是一个阿贝尔群。 椭圆曲线上的乘法 现在我们已经知道了如何计算加法，那么如何计算2P2P2P的值呢？ 其实2P2P2P就是P+PP + PP+P。还记得过两点做直线么？这里只有一个点P, 相当于P和Q重合，那么这段直线的斜率就是过P点的切线的斜率，直接求导。 k=3x12/2y1k = 3x_1^2/2y_1k=3x12​/2y1​ 这样带入上述公式 R=(x3,y3)R=(x_3,y_3)R=(x3​,y3​) x3=k2−x1−x2x_3 = k^2 - x_1 - x_2x3​=k2−x1​−x2​ y3=k(x1−x3)−y1y_3 = k(x_1 - x_3) - y_1y3​=k(x1​−x3​)−y1​ 就能得出R=2PR=2PR=2P的值了 如何计算3P3P3P的值呢？ 现在我们已经知道了2P2P2P的值，那么只需要计算2P+P=3P就可以啦设2P + P = 3P就可以啦 设2P+P=3P就可以啦设Q = 2P过 过过P$ 和 QQQ做直线，相交于R′R&#x27;R′, 过R′R&#x27;R′做XXX轴垂线相交于曲线另外一点RRR 那么RRR就是这里的3P3P3P的值啦 依此类推，我们可以计算nP(n&gt;0)nP(n&gt;0)nP(n&gt;0)的值 离散的特性 有空的同学务必要试一试 掏出纸和笔，设定随机点PPP画出7P7P7P的位置。 你会发现1P,2P,3P....7P1P,2P,3P....7P1P,2P,3P....7P的位置相差很大，没有规律可循。如果给定两点PPP以及7P7P7P的值，你能求出乘数777吗？ 即便是只有7，这里的计算量也是很大的，如果给定PPP和nPnPnP(nnn是一个22562^2562256的数字),那么逆推出nnn的难度就相当大了，以人类文明现有水平，很难在短时间（几百年）计算出结果。 这就是为什么椭圆曲线数字签名算法安全性这么高了。 签名过程 用户持有公钥KKK和私钥kkk, 以及原文MMM 验证过程 签名验证过程 ，更具体的,是secp256k1椭圆曲线。 https://en.bitcoin.it/wiki/Secp256k1 此椭圆曲线的方程是 y2=x3+7y^2 = x^3 + 7y2=x3+7 这个方程的图像看起来是这个样子： https://www.desmos.com/calculator/ialhd71we3 从r,s,v中反推出公钥","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://formyown.github.io/categories/以太坊/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://formyown.github.io/tags/Java/"},{"name":"以太坊","slug":"以太坊","permalink":"http://formyown.github.io/tags/以太坊/"},{"name":"Ethereum","slug":"Ethereum","permalink":"http://formyown.github.io/tags/Ethereum/"},{"name":"加密","slug":"加密","permalink":"http://formyown.github.io/tags/加密/"}]}]}